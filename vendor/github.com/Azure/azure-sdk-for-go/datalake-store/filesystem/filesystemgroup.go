package filesystem

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator 1.0.1.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

import (
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/satori/uuid"
	"io"
	"net/http"
)

// GroupClient is the creates an Azure Data Lake Store filesystem client.
type GroupClient struct {
	ManagementClient
}

// NewGroupClient creates an instance of the GroupClient client.
func NewGroupClient() GroupClient {
	return GroupClient{New()}
}

// Append used for serial appends to the specified file.Â NOTE: The target must
// not contain data added by ConcurrentAppend. ConcurrentAppend and Append
// cannot be used interchangeably; once a target file has been modified using
// either of these append options, the other append option cannot be used on
// the target file.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. directFilePath is the Data Lake Store path (starting with
// '/') of the file to which to append. streamContents is the file contents to
// include when appending to the file. streamContents will be closed upon
// successful return. Callers should ensure closure when receiving an error.op
// is the constant value for the operation. appendParameter is flag to skip
// redirection. When append=false or not specified, the request is redirected.
// Submit another HTTP PUT request using the URL in the Location header with
// the file data to be written. When append=true, this redirection is skipped.
// offset is the optional offset in the stream to begin the append operation.
// Default is to append at the end of the stream. syncFlag is optionally
// indicates what to do after completion of the append. DATA indicates more
// data is coming so no sync takes place, METADATA indicates a sync should be
// done to refresh metadata of the file only. CLOSE indicates that both the
// stream and metadata should be refreshed upon append completion. leaseID is
// optional unique GUID per file to ensure single writer semantics, meaning
// that only clients that append to the file with the same leaseId will be
// allowed to do so. fileSessionID is optional unique GUID per file indicating
// all the appends with the same fileSessionId are from the same client and
// same session. This will give a performance benefit when syncFlag is DATA or
// METADATA.
func (client GroupClient) Append(accountName string, directFilePath string, streamContents io.ReadCloser, op string, appendParameter string, offset *int64, syncFlag SyncFlag, leaseID *uuid.UUID, fileSessionID *uuid.UUID) (result autorest.Response, err error) {
	req, err := client.AppendPreparer(accountName, directFilePath, streamContents, op, appendParameter, offset, syncFlag, leaseID, fileSessionID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Append", nil, "Failure preparing request")
		return
	}

	resp, err := client.AppendSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Append", resp, "Failure sending request")
		return
	}

	result, err = client.AppendResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Append", resp, "Failure responding to request")
	}

	return
}

// AppendPreparer prepares the Append request.
func (client GroupClient) AppendPreparer(accountName string, directFilePath string, streamContents io.ReadCloser, op string, appendParameter string, offset *int64, syncFlag SyncFlag, leaseID *uuid.UUID, fileSessionID *uuid.UUID) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"directFilePath": autorest.Encode("path", directFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"append":      autorest.Encode("query", appendParameter),
		"op":          autorest.Encode("query", op),
	}
	if offset != nil {
		queryParameters["offset"] = autorest.Encode("query", *offset)
	}
	if len(string(syncFlag)) > 0 {
		queryParameters["syncFlag"] = autorest.Encode("query", syncFlag)
	}
	if leaseID != nil {
		queryParameters["leaseId"] = autorest.Encode("query", *leaseID)
	}
	if fileSessionID != nil {
		queryParameters["fileSessionId"] = autorest.Encode("query", *fileSessionID)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{directFilePath}", pathParameters),
		autorest.WithFile(streamContents),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// AppendSender sends the Append request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) AppendSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// AppendResponder handles the response to the Append request. The method always
// closes the http.Response Body.
func (client GroupClient) AppendResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// CheckAccess checks if the specified access is available at the given path.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. pathParameter is the Data Lake Store path (starting with '/')
// of the file or directory for which to check access. fsaction is file system
// operation read/write/execute in string form, matching regex pattern
// '[rwx-]{3}' op is the constant value for the operation.
func (client GroupClient) CheckAccess(accountName string, pathParameter string, fsaction string, op string) (result autorest.Response, err error) {
	req, err := client.CheckAccessPreparer(accountName, pathParameter, fsaction, op)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "CheckAccess", nil, "Failure preparing request")
		return
	}

	resp, err := client.CheckAccessSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "CheckAccess", resp, "Failure sending request")
		return
	}

	result, err = client.CheckAccessResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "CheckAccess", resp, "Failure responding to request")
	}

	return
}

// CheckAccessPreparer prepares the CheckAccess request.
func (client GroupClient) CheckAccessPreparer(accountName string, pathParameter string, fsaction string, op string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"path": autorest.Encode("path", pathParameter),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"fsaction":    autorest.Encode("query", fsaction),
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{path}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// CheckAccessSender sends the CheckAccess request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) CheckAccessSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// CheckAccessResponder handles the response to the CheckAccess request. The method always
// closes the http.Response Body.
func (client GroupClient) CheckAccessResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Concat concatenates the list of source files into the destination file,
// removing all source files upon success.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. destinationPath is the Data Lake Store path (starting with
// '/') of the destination file resulting from the concatenation. sources is a
// list of comma separated Data Lake Store paths (starting with '/') of the
// files to concatenate, in the order in which they should be concatenated. op
// is the constant value for the operation.
func (client GroupClient) Concat(accountName string, destinationPath string, sources []string, op string) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: sources,
			Constraints: []validation.Constraint{{Target: "sources", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "filesystem.GroupClient", "Concat")
	}

	req, err := client.ConcatPreparer(accountName, destinationPath, sources, op)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Concat", nil, "Failure preparing request")
		return
	}

	resp, err := client.ConcatSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Concat", resp, "Failure sending request")
		return
	}

	result, err = client.ConcatResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Concat", resp, "Failure responding to request")
	}

	return
}

// ConcatPreparer prepares the Concat request.
func (client GroupClient) ConcatPreparer(accountName string, destinationPath string, sources []string, op string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"destinationPath": autorest.Encode("path", destinationPath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
		"sources":     autorest.Encode("query", sources, ","),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{destinationPath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ConcatSender sends the Concat request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ConcatSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ConcatResponder handles the response to the Concat request. The method always
// closes the http.Response Body.
func (client GroupClient) ConcatResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ConcurrentAppend appends to the specified file, optionally first creating
// the file if it does not yet exist. This method supports multiple concurrent
// appends to the file. NOTE: The target must not contain data added by Create
// or normal (serial) Append. ConcurrentAppend and Append cannot be used
// interchangeably; once a target file has been modified using either of these
// append options, the other append option cannot be used on the target file.
// ConcurrentAppend does not guarantee order and can result in duplicated data
// landing in the target file.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. filePath is the Data Lake Store path (starting with '/') of
// the file to which to append using concurrent append. streamContents is the
// file contents to include when appending to the file. streamContents will be
// closed upon successful return. Callers should ensure closure when receiving
// an error.op is the constant value for the operation. transferEncoding is
// indicates the data being sent to the server is being streamed in chunks.
// appendMode is indicates the concurrent append call should create the file if
// it doesn't exist or just open the existing file for append syncFlag is
// optionally indicates what to do after completion of the concurrent append.
// DATA indicates more data is coming so no sync takes place, METADATA
// indicates a sync should be done to refresh metadata of the file only. CLOSE
// indicates that both the stream and metadata should be refreshed upon append
// completion.
func (client GroupClient) ConcurrentAppend(accountName string, filePath string, streamContents io.ReadCloser, op string, transferEncoding string, appendMode AppendModeType, syncFlag SyncFlag) (result autorest.Response, err error) {
	req, err := client.ConcurrentAppendPreparer(accountName, filePath, streamContents, op, transferEncoding, appendMode, syncFlag)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "ConcurrentAppend", nil, "Failure preparing request")
		return
	}

	resp, err := client.ConcurrentAppendSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "ConcurrentAppend", resp, "Failure sending request")
		return
	}

	result, err = client.ConcurrentAppendResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "ConcurrentAppend", resp, "Failure responding to request")
	}

	return
}

// ConcurrentAppendPreparer prepares the ConcurrentAppend request.
func (client GroupClient) ConcurrentAppendPreparer(accountName string, filePath string, streamContents io.ReadCloser, op string, transferEncoding string, appendMode AppendModeType, syncFlag SyncFlag) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"filePath": autorest.Encode("path", filePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if len(string(appendMode)) > 0 {
		queryParameters["appendMode"] = autorest.Encode("query", appendMode)
	}
	if len(string(syncFlag)) > 0 {
		queryParameters["syncFlag"] = autorest.Encode("query", syncFlag)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/WebHdfsExt/{filePath}", pathParameters),
		autorest.WithFile(streamContents),
		autorest.WithQueryParameters(queryParameters),
		autorest.WithHeader("Transfer-Encoding", autorest.String(transferEncoding)))
	return preparer.Prepare(&http.Request{})
}

// ConcurrentAppendSender sends the ConcurrentAppend request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ConcurrentAppendSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ConcurrentAppendResponder handles the response to the ConcurrentAppend request. The method always
// closes the http.Response Body.
func (client GroupClient) ConcurrentAppendResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Create creates a file with optionally specified content. NOTE: If content is
// provided, the resulting file cannot be modified using ConcurrentAppend.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. directFilePath is the Data Lake Store path (starting with
// '/') of the file to create. op is the constant value for the operation.
// write is flag to skip redirection. When write=false or not specified, the
// request is redirected. Submit another HTTP PUT request using the URL in the
// Location header with the file data to be written. When write=true, this
// redirection is skipped. streamContents is the file contents to include when
// creating the file. This parameter is optional, resulting in an empty file if
// not specified. streamContents will be closed upon successful return. Callers
// should ensure closure when receiving an error.overwrite is the indication of
// if the file should be overwritten. syncFlag is optionally indicates what to
// do after completion of the append. DATA indicates more data is coming so no
// sync takes place, METADATA indicates a sync should be done to refresh
// metadata of the file only. CLOSE indicates that both the stream and metadata
// should be refreshed upon create completion. leaseID is optional unique GUID
// per file to ensure single writer semantics, meaning that only clients that
// append to the file with the same leaseId will be allowed to do so.
// permission is the octal representation of the unnamed user, mask and other
// permissions that should be set for the file when created. If not specified,
// it inherits these from the container.
func (client GroupClient) Create(accountName string, directFilePath string, op string, write string, streamContents io.ReadCloser, overwrite *bool, syncFlag SyncFlag, leaseID *uuid.UUID, permission *int32) (result autorest.Response, err error) {
	req, err := client.CreatePreparer(accountName, directFilePath, op, write, streamContents, overwrite, syncFlag, leaseID, permission)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Create", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Create", resp, "Failure sending request")
		return
	}

	result, err = client.CreateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Create", resp, "Failure responding to request")
	}

	return
}

// CreatePreparer prepares the Create request.
func (client GroupClient) CreatePreparer(accountName string, directFilePath string, op string, write string, streamContents io.ReadCloser, overwrite *bool, syncFlag SyncFlag, leaseID *uuid.UUID, permission *int32) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"directFilePath": autorest.Encode("path", directFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
		"write":       autorest.Encode("query", write),
	}
	if overwrite != nil {
		queryParameters["overwrite"] = autorest.Encode("query", *overwrite)
	}
	if len(string(syncFlag)) > 0 {
		queryParameters["syncFlag"] = autorest.Encode("query", syncFlag)
	}
	if leaseID != nil {
		queryParameters["leaseId"] = autorest.Encode("query", *leaseID)
	}
	if permission != nil {
		queryParameters["permission"] = autorest.Encode("query", *permission)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{directFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if streamContents != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(streamContents))
	}
	return preparer.Prepare(&http.Request{})
}

// CreateSender sends the Create request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) CreateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// CreateResponder handles the response to the Create request. The method always
// closes the http.Response Body.
func (client GroupClient) CreateResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Delete deletes the requested file or directory, optionally recursively.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. filePath is the Data Lake Store path (starting with '/') of
// the file or directory to delete. op is the constant value for the operation.
// recursive is the optional switch indicating if the delete should be
// recursive
func (client GroupClient) Delete(accountName string, filePath string, op string, recursive *bool) (result FileOperationResult, err error) {
	req, err := client.DeletePreparer(accountName, filePath, op, recursive)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Delete", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Delete", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Delete", resp, "Failure responding to request")
	}

	return
}

// DeletePreparer prepares the Delete request.
func (client GroupClient) DeletePreparer(accountName string, filePath string, op string, recursive *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"filePath": autorest.Encode("path", filePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if recursive != nil {
		queryParameters["recursive"] = autorest.Encode("query", *recursive)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{filePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// DeleteSender sends the Delete request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) DeleteSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// DeleteResponder handles the response to the Delete request. The method always
// closes the http.Response Body.
func (client GroupClient) DeleteResponder(resp *http.Response) (result FileOperationResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetACLStatus gets Access Control List (ACL) entries for the specified file
// or directory.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. ACLFilePath is the Data Lake Store path (starting with '/')
// of the file or directory for which to get the ACL. op is the constant value
// for the operation. tooID is an optional switch to return friendly names in
// place of object ID for ACL entries. tooid=false returns friendly names
// instead of the AAD Object ID. Default value is true, returning AAD object
// IDs.
func (client GroupClient) GetACLStatus(accountName string, ACLFilePath string, op string, tooID *bool) (result ACLStatusResult, err error) {
	req, err := client.GetACLStatusPreparer(accountName, ACLFilePath, op, tooID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "GetACLStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetACLStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "GetACLStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetACLStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "GetACLStatus", resp, "Failure responding to request")
	}

	return
}

// GetACLStatusPreparer prepares the GetACLStatus request.
func (client GroupClient) GetACLStatusPreparer(accountName string, ACLFilePath string, op string, tooID *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"aclFilePath": autorest.Encode("path", ACLFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if tooID != nil {
		queryParameters["tooId"] = autorest.Encode("query", *tooID)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{aclFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetACLStatusSender sends the GetACLStatus request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetACLStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetACLStatusResponder handles the response to the GetACLStatus request. The method always
// closes the http.Response Body.
func (client GroupClient) GetACLStatusResponder(resp *http.Response) (result ACLStatusResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetContentSummary gets the file content summary object specified by the file
// path.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. getContentSummaryFilePath is the Data Lake Store path
// (starting with '/') of the file for which to retrieve the summary. op is the
// constant value for the operation.
func (client GroupClient) GetContentSummary(accountName string, getContentSummaryFilePath string, op string) (result ContentSummaryResult, err error) {
	req, err := client.GetContentSummaryPreparer(accountName, getContentSummaryFilePath, op)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "GetContentSummary", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetContentSummarySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "GetContentSummary", resp, "Failure sending request")
		return
	}

	result, err = client.GetContentSummaryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "GetContentSummary", resp, "Failure responding to request")
	}

	return
}

// GetContentSummaryPreparer prepares the GetContentSummary request.
func (client GroupClient) GetContentSummaryPreparer(accountName string, getContentSummaryFilePath string, op string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"getContentSummaryFilePath": autorest.Encode("path", getContentSummaryFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{getContentSummaryFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetContentSummarySender sends the GetContentSummary request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetContentSummarySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetContentSummaryResponder handles the response to the GetContentSummary request. The method always
// closes the http.Response Body.
func (client GroupClient) GetContentSummaryResponder(resp *http.Response) (result ContentSummaryResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetFileStatus get the file status object specified by the file path.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. getFilePath is the Data Lake Store path (starting with '/')
// of the file or directory for which to retrieve the status. op is the
// constant value for the operation. tooID is an optional switch to return
// friendly names in place of owner and group. tooid=false returns friendly
// names instead of the AAD Object ID. Default value is true, returning AAD
// object IDs.
func (client GroupClient) GetFileStatus(accountName string, getFilePath string, op string, tooID *bool) (result FileStatusResult, err error) {
	req, err := client.GetFileStatusPreparer(accountName, getFilePath, op, tooID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "GetFileStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetFileStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "GetFileStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetFileStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "GetFileStatus", resp, "Failure responding to request")
	}

	return
}

// GetFileStatusPreparer prepares the GetFileStatus request.
func (client GroupClient) GetFileStatusPreparer(accountName string, getFilePath string, op string, tooID *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"getFilePath": autorest.Encode("path", getFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if tooID != nil {
		queryParameters["tooId"] = autorest.Encode("query", *tooID)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{getFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetFileStatusSender sends the GetFileStatus request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetFileStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetFileStatusResponder handles the response to the GetFileStatus request. The method always
// closes the http.Response Body.
func (client GroupClient) GetFileStatusResponder(resp *http.Response) (result FileStatusResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListFileStatus get the list of file status objects specified by the file
// path, with optional pagination parameters
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. listFilePath is the Data Lake Store path (starting with '/')
// of the directory to list. op is the constant value for the operation.
// listSize is gets or sets the number of items to return. Optional. listAfter
// is gets or sets the item or lexographical index after which to begin
// returning results. For example, a file list of 'a','b','d' and listAfter='b'
// will return 'd', and a listAfter='c' will also return 'd'. Optional.
// listBefore is gets or sets the item or lexographical index before which to
// begin returning results. For example, a file list of 'a','b','d' and
// listBefore='d' will return 'a','b', and a listBefore='c' will also return
// 'a','b'. Optional. tooID is an optional switch to return friendly names in
// place of owner and group. tooid=false returns friendly names instead of the
// AAD Object ID. Default value is true, returning AAD object IDs.
func (client GroupClient) ListFileStatus(accountName string, listFilePath string, op string, listSize *int32, listAfter string, listBefore string, tooID *bool) (result FileStatusesResult, err error) {
	req, err := client.ListFileStatusPreparer(accountName, listFilePath, op, listSize, listAfter, listBefore, tooID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "ListFileStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListFileStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "ListFileStatus", resp, "Failure sending request")
		return
	}

	result, err = client.ListFileStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "ListFileStatus", resp, "Failure responding to request")
	}

	return
}

// ListFileStatusPreparer prepares the ListFileStatus request.
func (client GroupClient) ListFileStatusPreparer(accountName string, listFilePath string, op string, listSize *int32, listAfter string, listBefore string, tooID *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"listFilePath": autorest.Encode("path", listFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if listSize != nil {
		queryParameters["listSize"] = autorest.Encode("query", *listSize)
	}
	if len(listAfter) > 0 {
		queryParameters["listAfter"] = autorest.Encode("query", listAfter)
	}
	if len(listBefore) > 0 {
		queryParameters["listBefore"] = autorest.Encode("query", listBefore)
	}
	if tooID != nil {
		queryParameters["tooId"] = autorest.Encode("query", *tooID)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{listFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListFileStatusSender sends the ListFileStatus request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListFileStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ListFileStatusResponder handles the response to the ListFileStatus request. The method always
// closes the http.Response Body.
func (client GroupClient) ListFileStatusResponder(resp *http.Response) (result FileStatusesResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Mkdirs creates a directory.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. pathParameter is the Data Lake Store path (starting with '/')
// of the directory to create. op is the constant value for the operation.
// permission is optional octal permission with which the directory should be
// created.
func (client GroupClient) Mkdirs(accountName string, pathParameter string, op string, permission *int32) (result FileOperationResult, err error) {
	req, err := client.MkdirsPreparer(accountName, pathParameter, op, permission)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Mkdirs", nil, "Failure preparing request")
		return
	}

	resp, err := client.MkdirsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Mkdirs", resp, "Failure sending request")
		return
	}

	result, err = client.MkdirsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Mkdirs", resp, "Failure responding to request")
	}

	return
}

// MkdirsPreparer prepares the Mkdirs request.
func (client GroupClient) MkdirsPreparer(accountName string, pathParameter string, op string, permission *int32) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"path": autorest.Encode("path", pathParameter),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if permission != nil {
		queryParameters["permission"] = autorest.Encode("query", *permission)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{path}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// MkdirsSender sends the Mkdirs request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) MkdirsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// MkdirsResponder handles the response to the Mkdirs request. The method always
// closes the http.Response Body.
func (client GroupClient) MkdirsResponder(resp *http.Response) (result FileOperationResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ModifyACLEntries modifies existing Access Control List (ACL) entries on a
// file or folder.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. modifyACLFilePath is the Data Lake Store path (starting with
// '/') of the file or directory with the ACL being modified. aclspec is the
// ACL specification included in ACL modification operations in the format
// '[default:]user|group|other::r|-w|-x|-' op is the constant value for the
// operation.
func (client GroupClient) ModifyACLEntries(accountName string, modifyACLFilePath string, aclspec string, op string) (result autorest.Response, err error) {
	req, err := client.ModifyACLEntriesPreparer(accountName, modifyACLFilePath, aclspec, op)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "ModifyACLEntries", nil, "Failure preparing request")
		return
	}

	resp, err := client.ModifyACLEntriesSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "ModifyACLEntries", resp, "Failure sending request")
		return
	}

	result, err = client.ModifyACLEntriesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "ModifyACLEntries", resp, "Failure responding to request")
	}

	return
}

// ModifyACLEntriesPreparer prepares the ModifyACLEntries request.
func (client GroupClient) ModifyACLEntriesPreparer(accountName string, modifyACLFilePath string, aclspec string, op string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"modifyAclFilePath": autorest.Encode("path", modifyACLFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"aclspec":     autorest.Encode("query", aclspec),
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{modifyAclFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ModifyACLEntriesSender sends the ModifyACLEntries request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ModifyACLEntriesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ModifyACLEntriesResponder handles the response to the ModifyACLEntries request. The method always
// closes the http.Response Body.
func (client GroupClient) ModifyACLEntriesResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// MsConcat concatenates the list of source files into the destination file,
// deleting all source files upon success. This method accepts more source file
// paths than the Concat method. This method and the parameters it accepts are
// subject to change for usability in an upcoming version.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. msConcatDestinationPath is the Data Lake Store path (starting
// with '/') of the destination file resulting from the concatenation.
// streamContents is a list of Data Lake Store paths (starting with '/') of the
// source files. Must be a comma-separated path list in the format:
// sources=/file/path/1.txt,/file/path/2.txt,/file/path/lastfile.csv
// streamContents will be closed upon successful return. Callers should ensure
// closure when receiving an error.op is the constant value for the operation.
// deleteSourceDirectory is indicates that as an optimization instead of
// deleting each individual source stream, delete the source stream folder if
// all streams are in the same folder instead. This results in a substantial
// performance improvement when the only streams in the folder are part of the
// concatenation operation. WARNING: This includes the deletion of any other
// files that are not source files. Only set this to true when source files are
// the only files in the source directory.
func (client GroupClient) MsConcat(accountName string, msConcatDestinationPath string, streamContents io.ReadCloser, op string, deleteSourceDirectory *bool) (result autorest.Response, err error) {
	req, err := client.MsConcatPreparer(accountName, msConcatDestinationPath, streamContents, op, deleteSourceDirectory)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "MsConcat", nil, "Failure preparing request")
		return
	}

	resp, err := client.MsConcatSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "MsConcat", resp, "Failure sending request")
		return
	}

	result, err = client.MsConcatResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "MsConcat", resp, "Failure responding to request")
	}

	return
}

// MsConcatPreparer prepares the MsConcat request.
func (client GroupClient) MsConcatPreparer(accountName string, msConcatDestinationPath string, streamContents io.ReadCloser, op string, deleteSourceDirectory *bool) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"msConcatDestinationPath": autorest.Encode("path", msConcatDestinationPath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if deleteSourceDirectory != nil {
		queryParameters["deleteSourceDirectory"] = autorest.Encode("query", *deleteSourceDirectory)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{msConcatDestinationPath}", pathParameters),
		autorest.WithFile(streamContents),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// MsConcatSender sends the MsConcat request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) MsConcatSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// MsConcatResponder handles the response to the MsConcat request. The method always
// closes the http.Response Body.
func (client GroupClient) MsConcatResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Open opens and reads from the specified file.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. directFilePath is the Data Lake Store path (starting with
// '/') of the file to open. op is the constant value for the operation. read
// is flag to skip redirection. When read=false or not specified, the request
// is redirected. Submit another HTTP PUT request using the URL in the Location
// header with the file data to be read. When read=true, this redirection is
// skipped. length is the number of bytes that the server will attempt to
// retrieve. It will retrieve <= length bytes. offset is the byte offset to
// start reading data from. fileSessionID is optional unique GUID per file
// indicating all the reads with the same fileSessionId are from the same
// client and same session. This will give a performance benefit.
func (client GroupClient) Open(accountName string, directFilePath string, op string, read string, length *int64, offset *int64, fileSessionID *uuid.UUID) (result ReadCloser, err error) {
	req, err := client.OpenPreparer(accountName, directFilePath, op, read, length, offset, fileSessionID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Open", nil, "Failure preparing request")
		return
	}

	resp, err := client.OpenSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Open", resp, "Failure sending request")
		return
	}

	result, err = client.OpenResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Open", resp, "Failure responding to request")
	}

	return
}

// OpenPreparer prepares the Open request.
func (client GroupClient) OpenPreparer(accountName string, directFilePath string, op string, read string, length *int64, offset *int64, fileSessionID *uuid.UUID) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"directFilePath": autorest.Encode("path", directFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
		"read":        autorest.Encode("query", read),
	}
	if length != nil {
		queryParameters["length"] = autorest.Encode("query", *length)
	}
	if offset != nil {
		queryParameters["offset"] = autorest.Encode("query", *offset)
	}
	if fileSessionID != nil {
		queryParameters["fileSessionId"] = autorest.Encode("query", *fileSessionID)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{directFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// OpenSender sends the Open request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) OpenSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// OpenResponder handles the response to the Open request. The method always
// closes the http.Response Body.
func (client GroupClient) OpenResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK))
	result.Response = autorest.Response{Response: resp}
	return
}

// RemoveACL removes the existing Access Control List (ACL) of the specified
// file or directory.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. ACLFilePath is the Data Lake Store path (starting with '/')
// of the file or directory with the ACL being removed. op is the constant
// value for the operation.
func (client GroupClient) RemoveACL(accountName string, ACLFilePath string, op string) (result autorest.Response, err error) {
	req, err := client.RemoveACLPreparer(accountName, ACLFilePath, op)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "RemoveACL", nil, "Failure preparing request")
		return
	}

	resp, err := client.RemoveACLSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "RemoveACL", resp, "Failure sending request")
		return
	}

	result, err = client.RemoveACLResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "RemoveACL", resp, "Failure responding to request")
	}

	return
}

// RemoveACLPreparer prepares the RemoveACL request.
func (client GroupClient) RemoveACLPreparer(accountName string, ACLFilePath string, op string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"aclFilePath": autorest.Encode("path", ACLFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{aclFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// RemoveACLSender sends the RemoveACL request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) RemoveACLSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// RemoveACLResponder handles the response to the RemoveACL request. The method always
// closes the http.Response Body.
func (client GroupClient) RemoveACLResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RemoveACLEntries removes existing Access Control List (ACL) entries for a
// file or folder.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. removeACLFilePath is the Data Lake Store path (starting with
// '/') of the file or directory with the ACL being removed. aclspec is the ACL
// spec included in ACL removal operations in the format
// '[default:]user|group|other' op is the constant value for the operation.
func (client GroupClient) RemoveACLEntries(accountName string, removeACLFilePath string, aclspec string, op string) (result autorest.Response, err error) {
	req, err := client.RemoveACLEntriesPreparer(accountName, removeACLFilePath, aclspec, op)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "RemoveACLEntries", nil, "Failure preparing request")
		return
	}

	resp, err := client.RemoveACLEntriesSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "RemoveACLEntries", resp, "Failure sending request")
		return
	}

	result, err = client.RemoveACLEntriesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "RemoveACLEntries", resp, "Failure responding to request")
	}

	return
}

// RemoveACLEntriesPreparer prepares the RemoveACLEntries request.
func (client GroupClient) RemoveACLEntriesPreparer(accountName string, removeACLFilePath string, aclspec string, op string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"removeAclFilePath": autorest.Encode("path", removeACLFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"aclspec":     autorest.Encode("query", aclspec),
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{removeAclFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// RemoveACLEntriesSender sends the RemoveACLEntries request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) RemoveACLEntriesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// RemoveACLEntriesResponder handles the response to the RemoveACLEntries request. The method always
// closes the http.Response Body.
func (client GroupClient) RemoveACLEntriesResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RemoveDefaultACL removes the existing Default Access Control List (ACL) of
// the specified directory.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. defaultACLFilePath is the Data Lake Store path (starting with
// '/') of the directory with the default ACL being removed. op is the constant
// value for the operation.
func (client GroupClient) RemoveDefaultACL(accountName string, defaultACLFilePath string, op string) (result autorest.Response, err error) {
	req, err := client.RemoveDefaultACLPreparer(accountName, defaultACLFilePath, op)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "RemoveDefaultACL", nil, "Failure preparing request")
		return
	}

	resp, err := client.RemoveDefaultACLSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "RemoveDefaultACL", resp, "Failure sending request")
		return
	}

	result, err = client.RemoveDefaultACLResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "RemoveDefaultACL", resp, "Failure responding to request")
	}

	return
}

// RemoveDefaultACLPreparer prepares the RemoveDefaultACL request.
func (client GroupClient) RemoveDefaultACLPreparer(accountName string, defaultACLFilePath string, op string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"defaultAclFilePath": autorest.Encode("path", defaultACLFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{defaultAclFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// RemoveDefaultACLSender sends the RemoveDefaultACL request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) RemoveDefaultACLSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// RemoveDefaultACLResponder handles the response to the RemoveDefaultACL request. The method always
// closes the http.Response Body.
func (client GroupClient) RemoveDefaultACLResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Rename rename a file or directory.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. renameFilePath is the Data Lake Store path (starting with
// '/') of the file or directory to move/rename. destination is the path to
// move/rename the file or folder to op is the constant value for the
// operation.
func (client GroupClient) Rename(accountName string, renameFilePath string, destination string, op string) (result FileOperationResult, err error) {
	req, err := client.RenamePreparer(accountName, renameFilePath, destination, op)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Rename", nil, "Failure preparing request")
		return
	}

	resp, err := client.RenameSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Rename", resp, "Failure sending request")
		return
	}

	result, err = client.RenameResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "Rename", resp, "Failure responding to request")
	}

	return
}

// RenamePreparer prepares the Rename request.
func (client GroupClient) RenamePreparer(accountName string, renameFilePath string, destination string, op string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"renameFilePath": autorest.Encode("path", renameFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"destination": autorest.Encode("query", destination),
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{renameFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// RenameSender sends the Rename request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) RenameSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// RenameResponder handles the response to the Rename request. The method always
// closes the http.Response Body.
func (client GroupClient) RenameResponder(resp *http.Response) (result FileOperationResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// SetACL sets the Access Control List (ACL) for a file or folder.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. setACLFilePath is the Data Lake Store path (starting with
// '/') of the file or directory on which to set the ACL. aclspec is the ACL
// spec included in ACL creation operations in the format
// '[default:]user|group|other::r|-w|-x|-' op is the constant value for the
// operation.
func (client GroupClient) SetACL(accountName string, setACLFilePath string, aclspec string, op string) (result autorest.Response, err error) {
	req, err := client.SetACLPreparer(accountName, setACLFilePath, aclspec, op)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "SetACL", nil, "Failure preparing request")
		return
	}

	resp, err := client.SetACLSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "SetACL", resp, "Failure sending request")
		return
	}

	result, err = client.SetACLResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "SetACL", resp, "Failure responding to request")
	}

	return
}

// SetACLPreparer prepares the SetACL request.
func (client GroupClient) SetACLPreparer(accountName string, setACLFilePath string, aclspec string, op string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"setAclFilePath": autorest.Encode("path", setACLFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"aclspec":     autorest.Encode("query", aclspec),
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{setAclFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// SetACLSender sends the SetACL request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) SetACLSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// SetACLResponder handles the response to the SetACL request. The method always
// closes the http.Response Body.
func (client GroupClient) SetACLResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SetFileExpiry sets or removes the expiration time on the specified file.
// This operation can only be executed against files. Folders are not
// supported.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. filePath is the Data Lake Store path (starting with '/') of
// the file on which to set or remove the expiration time. expiryOption is
// indicates the type of expiration to use for the file: 1. NeverExpire:
// ExpireTime is ignored. 2. RelativeToNow: ExpireTime is an integer in
// milliseconds representing the expiration date relative to when file
// expiration is updated. 3. RelativeToCreationDate: ExpireTime is an integer
// in milliseconds representing the expiration date relative to file creation.
// 4. Absolute: ExpireTime is an integer in milliseconds, as a Unix timestamp
// relative to 1/1/1970 00:00:00. op is the constant value for the operation.
// expireTime is the time that the file will expire, corresponding to the
// ExpiryOption that was set.
func (client GroupClient) SetFileExpiry(accountName string, filePath string, expiryOption ExpiryOptionType, op string, expireTime *int64) (result autorest.Response, err error) {
	req, err := client.SetFileExpiryPreparer(accountName, filePath, expiryOption, op, expireTime)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "SetFileExpiry", nil, "Failure preparing request")
		return
	}

	resp, err := client.SetFileExpirySender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "SetFileExpiry", resp, "Failure sending request")
		return
	}

	result, err = client.SetFileExpiryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "SetFileExpiry", resp, "Failure responding to request")
	}

	return
}

// SetFileExpiryPreparer prepares the SetFileExpiry request.
func (client GroupClient) SetFileExpiryPreparer(accountName string, filePath string, expiryOption ExpiryOptionType, op string, expireTime *int64) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"filePath": autorest.Encode("path", filePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version":  APIVersion,
		"expiryOption": autorest.Encode("query", expiryOption),
		"op":           autorest.Encode("query", op),
	}
	if expireTime != nil {
		queryParameters["expireTime"] = autorest.Encode("query", *expireTime)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/WebHdfsExt/{filePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// SetFileExpirySender sends the SetFileExpiry request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) SetFileExpirySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// SetFileExpiryResponder handles the response to the SetFileExpiry request. The method always
// closes the http.Response Body.
func (client GroupClient) SetFileExpiryResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SetOwner sets the owner of a file or directory.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. setOwnerFilePath is the Data Lake Store path (starting with
// '/') of the file or directory for which to set the owner. op is the constant
// value for the operation. owner is the AAD Object ID of the user owner of the
// file or directory. If empty, the property will remain unchanged. group is
// the AAD Object ID of the group owner of the file or directory. If empty, the
// property will remain unchanged.
func (client GroupClient) SetOwner(accountName string, setOwnerFilePath string, op string, owner string, group string) (result autorest.Response, err error) {
	req, err := client.SetOwnerPreparer(accountName, setOwnerFilePath, op, owner, group)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "SetOwner", nil, "Failure preparing request")
		return
	}

	resp, err := client.SetOwnerSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "SetOwner", resp, "Failure sending request")
		return
	}

	result, err = client.SetOwnerResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "SetOwner", resp, "Failure responding to request")
	}

	return
}

// SetOwnerPreparer prepares the SetOwner request.
func (client GroupClient) SetOwnerPreparer(accountName string, setOwnerFilePath string, op string, owner string, group string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"setOwnerFilePath": autorest.Encode("path", setOwnerFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if len(owner) > 0 {
		queryParameters["owner"] = autorest.Encode("query", owner)
	}
	if len(group) > 0 {
		queryParameters["group"] = autorest.Encode("query", group)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{setOwnerFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// SetOwnerSender sends the SetOwner request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) SetOwnerSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// SetOwnerResponder handles the response to the SetOwner request. The method always
// closes the http.Response Body.
func (client GroupClient) SetOwnerResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SetPermission sets the permission of the file or folder.
//
// accountName is the Azure Data Lake Store account to execute filesystem
// operations on. setPermissionFilePath is the Data Lake Store path (starting
// with '/') of the file or directory for which to set the permission. op is
// the constant value for the operation. permission is a string representation
// of the permission (i.e 'rwx'). If empty, this property remains unchanged.
func (client GroupClient) SetPermission(accountName string, setPermissionFilePath string, op string, permission string) (result autorest.Response, err error) {
	req, err := client.SetPermissionPreparer(accountName, setPermissionFilePath, op, permission)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "SetPermission", nil, "Failure preparing request")
		return
	}

	resp, err := client.SetPermissionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "SetPermission", resp, "Failure sending request")
		return
	}

	result, err = client.SetPermissionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.GroupClient", "SetPermission", resp, "Failure responding to request")
	}

	return
}

// SetPermissionPreparer prepares the SetPermission request.
func (client GroupClient) SetPermissionPreparer(accountName string, setPermissionFilePath string, op string, permission string) (*http.Request, error) {
	urlParameters := map[string]interface{}{
		"accountName":             accountName,
		"adlsFileSystemDnsSuffix": client.AdlsFileSystemDNSSuffix,
	}

	pathParameters := map[string]interface{}{
		"setPermissionFilePath": autorest.Encode("path", setPermissionFilePath),
	}

	const APIVersion = "2016-11-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if len(permission) > 0 {
		queryParameters["permission"] = autorest.Encode("query", permission)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithCustomBaseURL("https://{accountName}.{adlsFileSystemDnsSuffix}", urlParameters),
		autorest.WithPathParameters("/webhdfs/v1/{setPermissionFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// SetPermissionSender sends the SetPermission request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) SetPermissionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// SetPermissionResponder handles the response to the SetPermission request. The method always
// closes the http.Response Body.
func (client GroupClient) SetPermissionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}
